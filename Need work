fix bug & unnaccassary/duplicate entry code from the below code and provide me with update by given full code:
// Constants
const DEFAULT_LOGO = '/assets/logo.png';
const DEFAULT_PLAYLIST_URL = 'https://raw.githubusercontent.com/bugsfreeweb/LiveTVCollector/refs/heads/main/LiveTV/Pakistan/LiveTV.m3u';
const PROBLEMATIC_DOMAINS = [
    'pluto.tv',
    'ythls.armelin.one',
    'varun-iptv.netlify.app',
    'ott.tv5monde.com',
    'bloomberg.com',
    'streaming.madanichannel.tv',
    'cdn.bmstudiopk.com',
    'arymusik.aryzap.com',
    '92news.vdn.dstreamone.net'
];
const KNOWN_BAD_IPS = ['89.254.128.5', '125.209.88.166'];
const BATCH_SIZE = 50;
const MAX_RETRIES = 3;
const BACKGROUND_CHECK_INTERVAL = 15 * 60 * 1000;

// DOM Elements
const elements = {
    sidebar: document.getElementById('sidebar'),
    playlist: document.getElementById('playlist'),
    searchInput: document.getElementById('searchInput'),
    groupFilter: document.getElementById('groupFilter'),
    startOverlay: document.getElementById('startOverlay'),
    errorToast: document.getElementById('errorToast'),
    loadingOverlay: document.getElementById('loadingOverlay'),
    playerContainer: document.getElementById('playerContainer'),
    tabs: document.querySelectorAll('.playlist-tab'),
    loadDefaultPlaylist: document.getElementById('loadDefaultPlaylist'),
    urlInput: document.getElementById('urlInput'),
    fileUpload: document.getElementById('fileUpload'),
    toggleSidebar: document.getElementById('toggleSidebar'),
    toggleTheme: document.getElementById('toggleTheme'),
    pipButton: document.getElementById('pipButton'),
    loadUrlBtn: document.getElementById('loadUrlBtn')
};

// State
let playlist = [];
let filteredPlaylist = [];
let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
let recent = JSON.parse(localStorage.getItem('recent')) || [];
let history = JSON.parse(localStorage.getItem('history')) || [];
let hls = null;
let dashPlayer = null;
let hasInteracted = false;
let retryCount = 0;
let currentIndex = -1;
let player = null;
let channelStats = { total: 0, online: 0, offline: 0 };
let statusChart = null;
let isValidating = false;
let isStatusRendering = false;

// Global for Multi-View
window.filteredPlaylist = filteredPlaylist;

// Utility Functions
function handleResourceError(resourceName) {
    showError(`${resourceName} failed to load. Some features may not work.`, 10000);
}

function initializePlayer() {
    try {
        if (typeof Plyr === 'undefined') {
            throw new Error('Plyr script not loaded');
        }
        const video = document.getElementById('player');
        if (!video) throw new Error('Video element not found');
        player = new Plyr(video, {
            controls: [
                'play-large', 'play', 'progress', 'current-time', 'mute', 'volume',
                'captions', 'settings', 'pip', 'airplay', 'fullscreen'
            ],
            settings: ['quality', 'speed'],
            quality: {
                default: 720,
                options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240]
            },
            autoplay: false,
            keyboard: { focused: true, global: true },
            ratio: null
        });
        player.on('error', handlePlayerError);
        player.on('playing', handlePlayerPlaying);
    } catch (e) {
        showError('Failed to initialize player: ' + e.message, 10000);
    }
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function showError(message, duration = 5000) {
    if (elements.errorToast) {
        elements.errorToast.textContent = message;
        elements.errorToast.style.display = 'block';
        setTimeout(() => {
            if (elements.errorToast) elements.errorToast.style.display = 'none';
        }, duration);
    }
}

function showNotification(message, duration = 6000) {
    let root = document.getElementById("notification-root");
    if (!root) {
        root = document.createElement("div");
        root.id = "notification-root";
        document.body.appendChild(root);
    }
    const toast = document.createElement("div");
    toast.className = "notification-toast";
    toast.innerHTML = message;
    root.appendChild(toast);
    setTimeout(() => {
        toast.remove();
    }, duration);
}

function handleFirstInteraction() {
    if (!hasInteracted && elements.startOverlay) {
        hasInteracted = true;
        elements.startOverlay.style.display = 'none';
    }
}

async function isStreamAccessible(url) {
    if (!url || PROBLEMATIC_DOMAINS.some(domain => url.includes(domain)) || KNOWN_BAD_IPS.some(ip => url.includes(ip))) {
        return false;
    }
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        await fetch(url, { method: 'HEAD', mode: 'no-cors', signal: controller.signal });
        clearTimeout(timeoutId);
        return true;
    } catch (e) {
        return false;
    }
}

function autoPlayFirstWorkingChannel(index) {
    if (index >= filteredPlaylist.length) {
        showError('No working channels found');
        return;
    }
    playVideo(filteredPlaylist[index].url, index);
}

function handleFileUpload(event) {
    try {
        const file = event.target.files?.[0];
        if (!file) {
            showError('No file selected');
            return;
        }
        const reader = new FileReader();
        reader.onload = e => {
            const content = e.target.result;
            const fileType = file.name.split('.').pop().toLowerCase();
            processContent(content, fileType);
            addToHistory(file.name, 'file', content);
        };
        reader.onerror = () => showError('Error reading file');
        reader.readAsText(file);
    } catch (e) {
        showError('Error handling file upload: ' + e.message);
    }
}

async function loadFromURL(urlOverride) {
    const url = urlOverride || elements.urlInput?.value.trim() || DEFAULT_PLAYLIST_URL;
    if (!url || !url.startsWith('http')) {
        showError('Enter a valid URL');
        return;
    }
    if (elements.loadingOverlay) elements.loadingOverlay.style.display = 'block';
    try {
        const response = await fetch(url, { mode: 'cors' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const content = await response.text();
        const fileType = url.split('.').pop().toLowerCase();
        await processContent(content, fileType === 'm3u8' ? 'm3u' : fileType);
        addToHistory(url, 'url', content);
    } catch (e) {
        showError('Error loading URL: ' + e.message);
    } finally {
        if (elements.loadingOverlay) elements.loadingOverlay.style.display = 'none';
    }
}

function addToHistory(name, type, content) {
    try {
        history.unshift({ name, type, content, timestamp: new Date().toISOString() });
        history = history.slice(0, 50);
        localStorage.setItem('history', JSON.stringify(history));
        localStorage.setItem('lastPlaylist', JSON.stringify({ content, type: name.split('.').pop().toLowerCase() }));
    } catch (e) {
        showError('Error saving history: ' + e.message);
    }
}

function clearHistory() {
    try {
        history = [];
        favorites = [];
        recent = [];
        localStorage.removeItem('history');
        localStorage.removeItem('favorites');
        localStorage.removeItem('recent');
        localStorage.removeItem('lastPlaylist');
        playlist = [];
        filteredPlaylist = [];
        channelStats = { total: 0, online: 0, offline: 0 };
        displayPlaylist('all');
    } catch (e) {
        showError('Error clearing history: ' + e.message);
    }
}

async function processContent(content, fileType) {
    if (!content || !fileType) {
        showError('Invalid content or file type');
        return;
    }
    if (elements.loadingOverlay) elements.loadingOverlay.style.display = 'block';
    try {
        const parsedPlaylist = parsePlaylist(content, fileType);
        if (parsedPlaylist.length === 0) {
            showError('No valid channels found');
            return;
        }
        playlist = parsedPlaylist;
        filteredPlaylist = [...playlist];
        window.filteredPlaylist = filteredPlaylist; // Update global
        channelStats = { total: parsedPlaylist.length, online: 0, offline: 0 };
        updateGroupFilter();
        displayPlaylist();
        localStorage.setItem('lastPlaylist', JSON.stringify({ content, type: fileType }));
        setTimeout(() => validatePlaylist(parsedPlaylist, false), 0);
    } catch (e) {
        showError('Error processing content: ' + e.message);
    } finally {
        if (elements.loadingOverlay) elements.loadingOverlay.style.display = 'none';
    }
}

async function validatePlaylist(parsedPlaylist, isManualResync = false) {
    if (isValidating) return;
    isValidating = true;
    try {
        if (isManualResync && elements.loadingOverlay) {
            elements.loadingOverlay.style.display = 'block';
        }
        const batchSize = BATCH_SIZE;
        const currentChannel = currentIndex >= 0 && currentIndex < playlist.length ? playlist[currentIndex] : null;
        let playlistToValidate = [...parsedPlaylist];
        if (currentChannel) {
            playlistToValidate = playlistToValidate.filter(item => item.url !== currentChannel.url);
            playlistToValidate.push(currentChannel);
        }
        channelStats = { total: playlist.length, online: 0, offline: 0 };
        for (let i = 0; i < playlistToValidate.length; i += batchSize) {
            const batch = playlistToValidate.slice(i, i + batchSize);
            const results = await Promise.all(batch.map(item => isStreamAccessible(item.url)));
            results.forEach((isValid, index) => {
                const playlistItem = playlist.find(p => p.url === batch[index].url);
                if (playlistItem) {
                    playlistItem.status = isValid ? 'online' : 'offline';
                    channelStats[isValid ? 'online' : 'offline']++;
                }
            });
            updateStatsAndUI();
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        filteredPlaylist = playlist.filter(item => item.status === 'online');
        window.filteredPlaylist = filteredPlaylist; // Update global
        updateStatsAndUI();
        if (currentChannel && currentChannel.status === 'offline' && currentIndex >= 0) {
            showError('Current channel is offline, switching to next available');
            autoPlayFirstWorkingChannel(currentIndex + 1);
        }
    } catch (e) {
        showError('Error validating playlist: ' + e.message);
    } finally {
        isValidating = false;
        if (isManualResync && elements.loadingOverlay) elements.loadingOverlay.style.display = 'none';
    }
}

function updateStatsAndUI() {
    requestAnimationFrame(() => {
        try {
            updateGroupFilter();
            const activeTab = document.querySelector('.playlist-tab.active')?.dataset.tab || 'all';
            if (activeTab === 'status' && !isStatusRendering) {
                isStatusRendering = true;
                renderStatusTab();
                setTimeout(() => { isStatusRendering = false; }, 100);
            } else {
                displayPlaylist(activeTab);
            }
        } catch (e) {
            isStatusRendering = false;
            showError('Error updating UI: ' + e.message);
        }
    });
}

function backgroundStatusCheck() {
    if (playlist.length === 0 || isValidating) {
        return;
    }
    validatePlaylist([...playlist], false);
}

function parsePlaylist(content, fileType) {
    let urls = [];
    try {
        switch (fileType) {
            case 'm3u':
            case 'm3u8': {
                const lines = content.split('\n').map(line => line.trim()).filter(line => line);
                let currentName = '', currentGroup = '', currentLogo = '';
                for (let line of lines) {
                    if (line.startsWith('#EXTINF:')) {
                        const matches = line.match(/#EXTINF:.*?(?:tvg-name="([^"]*)"|,([^,]*?)(?=\s*(?:tvg-|group-title|$)))?(?:tvg-logo="([^"]*)")?.*?(?:group-title="([^"]*)")?,(.*)/i) || [];
                        currentName = matches[5]?.trim() || matches[1]?.trim() || matches[2]?.trim() || `Channel ${urls.length + 1}`;
                        currentLogo = matches[3] || DEFAULT_LOGO;
                        currentGroup = matches[4] || 'Uncategorized';
                    } else if (line && !line.startsWith('#') && line.startsWith('http')) {
                        const url = line.replace(/^http:\/\//, 'https://');
                        if (!PROBLEMATIC_DOMAINS.some(domain => url.includes(domain)) && !KNOWN_BAD_IPS.some(ip => url.includes(ip))) {
                            urls.push({
                                url,
                                name: currentName,
                                logo: currentLogo,
                                group: currentGroup,
                                status: 'unknown'
                            });
                        }
                        currentName = currentLogo = currentGroup = '';
                    }
                }
                break;
            }
            case 'json': {
                const parsed = JSON.parse(content);
                urls = Array.isArray(parsed) ? parsed.map((item, i) => {
                    const url = item.url?.replace(/^http:\/\//, 'https://') || item;
                    if (PROBLEMATIC_DOMAINS.some(domain => url.includes(domain)) || KNOWN_BAD_IPS.some(ip => url.includes(ip))) {
                        return null;
                    }
                    return {
                        url,
                        name: item.name || `Channel ${i + 1}`,
                        logo: item.logo || DEFAULT_LOGO,
                        group: item.group || 'Uncategorized',
                        status: 'unknown'
                    };
                }).filter(item => item) : [];
                break;
            }
            case 'txt': {
                urls = content.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.startsWith('http'))
                    .map((line, i) => {
                        const url = line.replace(/^http:\/\//, 'https://');
                        if (PROBLEMATIC_DOMAINS.some(domain => url.includes(domain)) || KNOWN_BAD_IPS.some(ip => url.includes(ip))) {
                            return null;
                        }
                        return {
                            url,
                            name: `Channel ${i + 1}`,
                            logo: DEFAULT_LOGO,
                            group: 'Uncategorized',
                            status: 'unknown'
                        };
                    }).filter(item => item);
                break;
            }
            default: {
                const url = content.trim().replace(/^http:\/\//, 'https://');
                if (url.startsWith('https') && !PROBLEMATIC_DOMAINS.some(domain => url.includes(domain)) && !KNOWN_BAD_IPS.some(ip => url.includes(ip))) {
                    urls = [{
                        url,
                        name: 'Single Stream',
                        logo: DEFAULT_LOGO,
                        group: 'Uncategorized',
                        status: 'unknown'
                    }];
                }
            }
        }
    } catch (e) {
        showError('Error parsing playlist: ' + e.message);
        return [];
    }
    return urls.filter(item => item && item.url && item.url.startsWith('https'));
}

function updateGroupFilter() {
    try {
        if (!elements.groupFilter) return;
        const groups = [...new Set(filteredPlaylist.map(item => item.group))].sort();
        elements.groupFilter.innerHTML = '<option value="all">All Groups</option>';
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group;
            option.textContent = group;
            elements.groupFilter.appendChild(option);
        });
    } catch (e) {
        showError('Error updating group filter: ' + e.message);
    }
}

function displayPlaylist(tab = 'all') {
    try {
        if (!elements.playlist) return;
        elements.playlist.innerHTML = '';
        let displayList;
        if (tab === 'favorites') {
            displayList = playlist.filter(item => favorites.includes(item.url) && item.status === 'online');
            renderChannelList(displayList);
        } else if (tab === 'recent') {
            displayList = playlist.filter(item => recent.includes(item.url) && item.status === 'online');
            renderChannelList(displayList);
        } else if (tab === 'status') {
            renderStatusTab();
        } else if (tab === 'history') {
            renderHistoryTab();
        } else {
            displayList = filteredPlaylist;
            renderChannelList(displayList);
        }
    } catch (e) {
        showError('Error displaying playlist: ' + e.message);
    }
}

function renderChannelList(displayList) {
    try {
        const selectedGroup = elements.groupFilter?.value;
        if (selectedGroup && selectedGroup !== 'all') {
            displayList = displayList.filter(item => item.group === selectedGroup);
        }
        const prevScrollTop = elements.playlist.scrollTop;
        elements.playlist.innerHTML = '';
        displayList.forEach((item, index) => {
            const isProblematic = PROBLEMATIC_DOMAINS.some(domain => item.url.includes(domain)) ||
                                 KNOWN_BAD_IPS.some(ip => item.url.includes(ip));
            const globalIndex = filteredPlaylist.indexOf(item);
            const li = document.createElement('div');
            li.className = `playlist-item ${globalIndex === currentIndex ? 'active' : ''}`;
            li.innerHTML = `
                <img src="${item.logo}" alt="" onerror="this.src='/assets/fallback-logo.png';">
                <div class="info">
                    <div class="channel-name">${item.name}</div>
                    ${isProblematic ? `<div style="color:#ef4444;font-size:0.8em;">[Blocked: CORS/IP/Domain]</div>` : ''}
                </div>
                <span class="now-playing">Now Playing</span>
                <button class="favorite-btn ${favorites.includes(item.url) ? 'active' : ''}" data-url="${item.url}">
                    <span data-feather="star"></span>
                </button>
                <span class="status-indicator ${item.status}"></span>
            `;
            li.onclick = e => {
                if (e.target.closest('.favorite-btn')) return;
                if (isProblematic) {
                    showError('Channel cannot be played in browser (CORS/IP restriction)');
                    return;
                }
                playVideo(item.url, globalIndex);
            };
            elements.playlist.appendChild(li);
        });
        document.querySelectorAll('.favorite-btn').forEach(btn => {
            btn.addEventListener('click', toggleFavorite);
        });
        elements.playlist.scrollTop = prevScrollTop;
        if (window.feather) feather.replace();
    } catch (e) {
        showError('Error rendering channel list: ' + e.message);
    }
}

function renderStatusTab() {
    try {
        elements.playlist.innerHTML = '';
        const statusDiv = document.createElement('div');
        statusDiv.className = 'status-container';
        statusDiv.innerHTML = `
            <h3>Playlist Status</h3>
            <div class="stats">
                <div class="stat">Total: <span>${channelStats.total}</span></div>
                <div class="stat">Online: <span>${channelStats.online}</span></div>
                <div class="stat">Offline: <span>${channelStats.offline}</span></div>
            </div>
            <div style="display: flex; justify-content: center;">
                <canvas id="statusChart" width="180" height="180" style="max-width: 200px; max-height: 200px; margin: 0 auto; display: ${channelStats.total > 0 ? 'block' : 'none'}"></canvas>
            </div>
            <p id="chartError" style="display: ${channelStats.total > 0 ? 'none' : 'block'}; color: #ef4444;">No data to display</p>
            <button class="resync-btn" onclick="resyncPlaylist()">
                <span data-feather="refresh-cw"></span> Resync Now
            </button>
            <button class="view-playlist-btn" onclick="switchToTab('all')">
                <span data-feather="list"></span> View Playlist
            </button>
        `;
        elements.playlist.appendChild(statusDiv);

        if (channelStats.total === 0) return;

        if (typeof Chart === 'undefined') {
            document.getElementById('chartError').style.display = 'block';
            document.getElementById('chartError').textContent = 'Chart.js failed to load';
            showError('Chart.js not loaded. Status chart unavailable.', 10000);
            return;
        }

        const canvas = document.getElementById('statusChart');
        if (!canvas) {
            document.getElementById('chartError').style.display = 'block';
            document.getElementById('chartError').textContent = 'Chart canvas not found';
            showError('Chart canvas not found.', 10000);
            return;
        }

        if (statusChart) {
            statusChart.destroy();
            statusChart = null;
        }

        canvas.width = 180;
        canvas.height = 180;

        const ctx = canvas.getContext('2d');
        statusChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Online', 'Offline'],
                datasets: [{
                    data: [channelStats.online, channelStats.offline],
                    backgroundColor: ['#22c55e', '#ef4444'],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: false,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            color: document.body.classList.contains('light') ? '#1f2a44' : '#e0e6ed'
                        }
                    }
                }
            }
        });
        if (window.feather) feather.replace();
    } catch (e) {
        showError('Error rendering status tab: ' + e.message);
    }
}

async function resyncPlaylist() {
    try {
        if (playlist.length === 0) {
            showError('No playlist loaded to resync');
            return;
        }
        channelStats = { total: playlist.length, online: 0, offline: 0 };
        elements.playlist.innerHTML = '';
        await validatePlaylist([...playlist], true);
    } catch (e) {
        showError('Error resyncing playlist: ' + e.message);
    }
}

function renderHistoryTab() {
    try {
        const historyDiv = document.createElement('div');
        historyDiv.className = 'history-container';
        historyDiv.innerHTML = `<h3>Playlist History</h3>`;
        history.forEach((item, index) => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'history-item';
            itemDiv.innerHTML = `
                <div class="info">
                    <div class="name">${item.name}</div>
                    <div class="type">${item.type.charAt(0).toUpperCase() + item.type.slice(1)} - ${new Date(item.timestamp).toLocaleString()}</div>
                </div>
                <button class="reload-btn" data-index="${index}" title="Reload">
                    <span data-feather="refresh-cw"></span>
                </button>
                <button class="delete-btn" data-index="${index}" title="Delete">
                    <span data-feather="trash-2"></span>
                </button>
            `;
            historyDiv.appendChild(itemDiv);
        });

        const deleteAllBtn = document.createElement('button');
        deleteAllBtn.className = 'delete-all-btn';
        deleteAllBtn.innerHTML = '<span data-feather="trash"></span> Delete All History';
        deleteAllBtn.onclick = clearHistory;
        historyDiv.appendChild(deleteAllBtn);

        elements.playlist.appendChild(historyDiv);

        document.querySelectorAll('.reload-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = btn.dataset.index;
                const item = history[index];
                if (item.type === 'url') {
                    loadFromURL(item.name);
                } else {
                    processContent(item.content, item.name.split('.').pop().toLowerCase());
                }
            });
        });

        document.querySelectorAll('.delete-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = btn.dataset.index;
                history.splice(index, 1);
                localStorage.setItem('history', JSON.stringify(history));
                displayPlaylist('history');
            });
        });

        if (window.feather) feather.replace();
    } catch (e) {
        showError('Error rendering history tab: ' + e.message);
    }
}

function toggleFavorite(e) {
    try {
        const url = e.target.closest('.favorite-btn')?.dataset.url;
        if (!url) return;
        if (favorites.includes(url)) {
            favorites = favorites.filter(f => f !== url);
        } else {
            favorites.push(url);
        }
        localStorage.setItem('favorites', JSON.stringify(favorites));
        displayPlaylist(document.querySelector('.playlist-tab.active')?.dataset.tab || 'all');
    } catch (e) {
        showError('Error toggling favorite: ' + e.message);
    }
}

function addToRecent(url) {
    try {
        if (!url || recent.includes(url)) return;
        recent.unshift(url);
        if (recent.length > 10) recent.pop();
        localStorage.setItem('recent', JSON.stringify(recent));
    } catch (e) {
        showError('Error adding to recent: ' + e.message);
    }
}

function playVideo(url, index, isRetry = false) {
    try {
        if (
            PROBLEMATIC_DOMAINS.some(domain => url.includes(domain)) ||
            KNOWN_BAD_IPS.some(ip => url.includes(ip))
        ) {
            showError('This channel is blocked due to CORS/IP restriction and cannot be played in browsers.');
            return;
        }
        if (!player || !url || index < 0 || !filteredPlaylist[index]) {
            showError('Invalid video parameters');
            return;
        }
        const video = document.getElementById('player');
        if (!video) {
            showError('Video element not found');
            return;
        }
        currentIndex = index;
        updateStatus(index, 'loading');
        addToRecent(url);

        if (hls) {
            try { hls.destroy(); } catch (e) { }
            hls = null;
        }
        if (dashPlayer) {
            try { dashPlayer.reset(); } catch (e) { }
            dashPlayer = null;
        }
        if (!isRetry) retryCount = 0;

        const handlePlayError = error => {
            updateStatus(index, 'error');
            let errorMessage = error.message || 'Unknown error';
            let skipRetries = false;
            if (errorMessage.includes('CORS') || errorMessage.includes('Access-Control-Allow-Origin') || error.response?.code === 0) {
                errorMessage = 'Channel blocked by CORS policy';
                skipRetries = true;
            } else if (errorMessage.includes('ERR_CONNECTION_TIMED_OUT') || error.name === 'AbortError') {
                errorMessage = 'Channel timed out';
                skipRetries = true;
            } else if (error.response?.code === 404 || (error.networkDetails && error.networkDetails.status === 404)) {
                errorMessage = 'Channel not found (404)';
                skipRetries = true;
            } else if (error.response?.code === 403 || error.networkDetails?.status === 403) {
                errorMessage = 'Channel access forbidden (403)';
                skipRetries = true;
            } else {
                errorMessage = `Playback error: ${errorMessage}`;
            }
            showError(errorMessage);
            if (skipRetries || retryCount >= MAX_RETRIES) {
                retryCount = 0;
                if (index < filteredPlaylist.length - 1) {
                    showError('Trying next channel...');
                    setTimeout(() => autoPlayFirstWorkingChannel(index + 1), 1000);
                } else {
                    showError('No more channels to try');
                }
            } else {
                retryCount++;
                setTimeout(() => playVideo(url, index, true), 1000);
            }
        };

        const streamType = getStreamType(url);
        if (streamType === 'application/x-mpegURL' && typeof Hls !== 'undefined' && Hls.isSupported()) {
            hls = new Hls({
                enableWorker: true,
                lowLatencyMode: true,
                backBufferLength: 90,
                autoLevelCapping: -1,
                startLevel: -1,
                abrEwmaDefaultEstimate: 500000,
                abrMaxWithRealBitrate: true,
                xhrSetup: (xhr) => {
                    xhr.timeout = 5000;
                    xhr.withCredentials = false;
                }
            });
            hls.loadSource(url);
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, () => {
                video.play().then(() => {
                    updateStatus(index, 'playing');
                    if (elements.startOverlay) elements.startOverlay.style.display = 'none';
                    displayPlaylist(document.querySelector('.playlist-tab.active')?.dataset.tab || 'all');
                }).catch(handlePlayError);
            });
            hls.on(Hls.Events.ERROR, (event, data) => {
                if (data.fatal) {
                    let error = new Error(data.details);
                    if (data.response) error.response = { code: data.response.code };
                    if (data.networkDetails && data.networkDetails.status) {
                        error.networkDetails = { status: data.networkDetails.status };
                    }
                    handlePlayError(error);
                }
            });
        } else if (streamType === 'application/dash+xml' && typeof dashjs !== 'undefined' && dashjs.MediaPlayer) {
            dashPlayer = dashjs.MediaPlayer().create();
            dashPlayer.initialize(video, url, false);
            video.play().then(() => {
                updateStatus(index, 'playing');
                if (elements.startOverlay) elements.startOverlay.style.display = 'none';
                displayPlaylist(document.querySelector('.playlist-tab.active')?.dataset.tab || 'all');
            }).catch(handlePlayError);
        } else if (video.canPlayType(streamType) || streamType === 'video/mp4' || streamType === 'video/webm') {
            video.src = url;
            video.addEventListener('loadedmetadata', () => {
                video.play().then(() => {
                    updateStatus(index, 'playing');
                    if (elements.startOverlay) elements.startOverlay.style.display = 'none';
                    displayPlaylist(document.querySelector('.playlist-tab.active')?.dataset.tab || 'all');
                }).catch(handlePlayError);
            }, { once: true });
        } else {
            player.source = {
                type: 'video',
                sources: [{ src: url, type: streamType }]
            };
            video.play().then(() => {
                updateStatus(index, 'playing');
                if (elements.startOverlay) elements.startOverlay.style.display = 'none';
                displayPlaylist(document.querySelector('.playlist-tab.active')?.dataset.tab || 'all');
            }).catch(handlePlayError);
        }
        document.querySelectorAll('.playlist-item').forEach((item, i) => {
            item.classList.toggle('active', i === index);
        });
    } catch (error) {
        handlePlayError(error);
    }
}

function getStreamType(url) {
    try {
        const extensions = {
            'm3u8': 'application/x-mpegURL',
            'ts': 'video/mp2t',
            'mpd': 'application/dash+xml',
            'mp4': 'video/mp4',
            'mkv': 'video/webm',
            'webm': 'video/webm'
        };
        const ext = url.split('.').pop()?.toLowerCase() || 'mp4';
        return extensions[ext] || 'video/mp4';
    } catch (e) {
        return 'video/mp4';
    }
}

function updateStatus(index, status) {
    try {
        if (index < 0 || index >= filteredPlaylist.length) return;
        filteredPlaylist[index].status = status;
        window.filteredPlaylist = filteredPlaylist; // Update global
        const items = document.querySelectorAll('.playlist-item');
        const indicator = items[index]?.querySelector('.status-indicator');
        if (indicator) {
            indicator.classList.remove('loading', 'playing', 'error', 'online', 'offline', 'unknown');
            indicator.classList.add(status);
        }
    } catch (e) {
        showError('Error updating status: ' + e.message);
    }
}

function toggleSidebar() {
    try {
        if (elements.sidebar) elements.sidebar.classList.toggle('collapsed');
    } catch (e) {
        showError('Error toggling sidebar: ' + e.message);
    }
}

function toggleTheme() {
    try {
        document.body.classList.toggle('light');
        if (elements.toggleTheme) {
            elements.toggleTheme.innerHTML = document.body.classList.contains('light')
                ? '<span data-feather="sun"></span>'
                : '<span data-feather="moon"></span>';
            if (window.feather) feather.replace();
        }
        if (statusChart) {
            statusChart.options.plugins.legend.labels.color = document.body.classList.contains('light') ? '#1f2a44' : '#e0e6ed';
            statusChart.update();
        }
    } catch (e) {
        showError('Error toggling theme: ' + e.message);
    }
}

async function togglePiP() {
    try {
        const video = document.getElementById('player');
        if (!video) throw new Error('Video element not found');
        if (document.pictureInPictureElement) {
            await document.exitPictureInPicture();
        } else {
            await video.requestPictureInPicture();
        }
    } catch (e) {
        showError('Picture-in-Picture not supported or failed: ' + e.message);
    }
}

function switchTab(e) {
    try {
        elements.tabs.forEach(tab => tab.classList.remove('active'));
        const tabElement = e.target.closest('.playlist-tab');
        tabElement.classList.add('active');
        displayPlaylist(tabElement.dataset.tab);
    } catch (e) {
        showError('Error switching tab: ' + e.message);
    }
}

function switchToTab(tabName) {
    try {
        const tabElement = Array.from(elements.tabs).find(tab => tab.dataset.tab === tabName);
        if (!tabElement) throw new Error(`Tab ${tabName} not found`);
        elements.tabs.forEach(tab => tab.classList.remove('active'));
        tabElement.classList.add('active');
        displayPlaylist(tabName);
    } catch (e) {
        showError('Error switching to tab: ' + e.message);
    }
}

function handleSearch(e) {
    try {
        const searchTerm = e.target.value?.toLowerCase() || '';
        filteredPlaylist = playlist.filter(item =>
            item.name.toLowerCase().includes(searchTerm) &&
            (item.status === 'online' || item.status === 'unknown')
        );
        window.filteredPlaylist = filteredPlaylist; // Update global
        displayPlaylist(document.querySelector('.playlist-tab.active')?.dataset.tab || 'all');
    } catch (e) {
        showError('Error searching: ' + e.message);
    }
}

function handleGroupFilter(e) {
    try {
        filteredPlaylist = e.target.value === 'all'
            ? playlist.filter(item => item.status === 'online' || item.status === 'unknown')
            : playlist.filter(item => item.group === e.target.value && (item.status === 'online' || item.status === 'unknown'));
        window.filteredPlaylist = filteredPlaylist; // Update global
        displayPlaylist(document.querySelector('.playlist-tab.active')?.dataset.tab || 'all');
    } catch (e) {
        showError('Error filtering groups: ' + e.message);
    }
}

function handleShortcuts(e) {
    try {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
        switch (e.key.toLowerCase()) {
            case ' ':
                if (player) {
                    player.playing ? player.pause() : player.play();
                    e.preventDefault();
                }
                break;
            case 'f':
                if (player) player.fullscreen.toggle();
                break;
            case 'm':
                if (player) player.muted = !player.muted;
                break;
            case 's':
                toggleSidebar();
                break;
            case 'p':
                togglePiP();
                break;
        }
    } catch (e) {
        showError('Error handling keyboard shortcut: ' + e.message);
    }
}

function handlePlayerError() {
    try {
        updateStatus(currentIndex, 'error');
        if (currentIndex >= 0 && currentIndex < filteredPlaylist.length - 1) {
            showError('Error playing channel. Trying next...');
            setTimeout(() => autoPlayFirstWorkingChannel(currentIndex + 1), 1000);
        }
    } catch (e) {
        showError('Error in player error handler: ' + e.message);
    }
}

function handlePlayerPlaying() {
    try {
        updateStatus(currentIndex, 'playing');
        displayPlaylist(document.querySelector('.playlist-tab.active')?.dataset.tab || 'all');
    } catch (e) {
        showError('Error in player playing handler: ' + e.message);
    }
}

// Advanced Features
async function fetchChannelLogo(channelName) {
    try {
        const resp = await fetch(`https://iptv-org.github.io/api/channels.json`);
        const channels = await resp.json();
        const found = channels.find(c =>
            c.name && c.name.toLowerCase() === channelName.toLowerCase()
        );
        return found && found.logo ? found.logo : null;
    } catch {
        return null;
    }
}

function showChannelInfoOverlay(info) {
    const overlay = document.getElementById('channelInfoOverlay');
    overlay.innerHTML = `
        <img src="${info.logo || '/assets/logo.png'}" alt="logo" onerror="this.src='/assets/logo.png';">
        <div>
            <strong>${info.name}</strong><br>
            <span>${info.group || ""}</span>
            ${info.program ? `<br><small>Now: ${info.program}</small>` : ""}
        </div>
    `;
    overlay.style.display = "flex";
    setTimeout(() => { overlay.style.display = "none"; }, 6000);
}

function scheduleReminder(channelName, programTitle, startTime) {
    const now = Date.now();
    const delay = new Date(startTime).getTime() - now;
    if (delay > 0) {
        setTimeout(() => {
            showNotification(`🔔 Reminder: "${programTitle}" on ${channelName} is starting now!`);
        }, delay);
    }
}

function showMultiViewGuide() {
    showNotification(`
        <div style="max-width:350px;line-height:1.55;">
        <b>Multi-View Guide:</b><br>
        1. Click <span style="vertical-align:middle;"><span data-feather="grid"></span></span> Multi-View.<br>
        2. Select a channel in each window's dropdown.<br>
        3. Watch up to 4 channels at once.<br>
        4. Click <span style="vertical-align:middle;"><span data-feather="x-circle"></span></span> to close.<br>
        <b>Tip:</b> Change channels anytime in any grid!
        </div>
    `, 12000);
    if (window.feather) feather.replace();
}

function showMultiViewModal() {
    const modalRoot = document.getElementById('modalRoot');
    const fpl = window.filteredPlaylist || [];
    const options = fpl.length > 0
        ? fpl.map((ch, i) => `<option value="${i}">${ch.name}</option>`).join('')
        : '';
    if (!options) {
        modalRoot.innerHTML = `
          <div class="multi-view-modal" id="multiViewModal">
            <div style="color:#fff;background:#222;padding:32px;border-radius:12px;min-width:300px">
              No channels available for multi-view.<br><br>
              <button class="multi-view-close-btn" aria-label="Close Multi-View"><span data-feather='x'></span></button>
            </div>
          </div>
        `;
        setupMultiViewCloseBtn();
        if (window.feather) feather.replace();
        return;
    }
    modalRoot.innerHTML = `
      <div class="multi-view-modal" id="multiViewModal">
        <button class="multi-view-close-btn" aria-label="Close Multi-View" title="Close"></button>
        <div class="multi-view-grid" style="grid-template-columns: repeat(2, 320px); grid-template-rows: repeat(2, 180px);">
          ${[0,1,2,3].map(idx => `
            <div class="multi-view-cell">
              <select class="multi-view-select" data-cell="${idx}" style="position Xerox:absolute;top:8px;left:8px;z-index:2;">
                <option value="">Select channel</option>
                ${options}
              </select>
              <video data-cell="${idx}" style="width:100%;height:100%;object-fit:cover;position:relative;z-index:1;" controls autoplay muted poster="/assets/player-poster.webp"></video>
            </div>
          `).join('')}
        </div>
      </div>
    `;
    const closeBtn = document.querySelector('.multi-view-close-btn');
    closeBtn.innerHTML = '<span data-feather="x-circle" style="width:32px;height:32px;"></span>';
    Object.assign(closeBtn.style, {
        position: 'absolute',
        top: '24px',
        right: '32px',
        background: 'rgba(30,30,30,0.85)',
        color: '#fff',
        border: 'none',
        borderRadius: '50%',
        width: '48px',
        height: '48px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'pointer',
        zIndex: '10000',
        boxShadow: '0 2px 8px #0006'
    });
    closeBtn.addEventListener('click', closeMultiViewModal);
    document.addEventListener('keydown', escMultiViewClose, { once: true });
    document.querySelectorAll('.multi-view-select').forEach(sel => {
        sel.addEventListener('change', e => {
            const idx = parseInt(sel.dataset.cell, 10);
            const vid = document.querySelector(`.multi-view-cell video[data-cell="${idx}"]`);
            const val = sel.value;
            if (!val) {
                if (vid._hls) { vid._hls.destroy(); vid._hls = null; }
                vid.pause();
                vid.removeAttribute('src');
                vid.load();
                return;
            }
            const channel = fpl[parseInt(val, 10)];
            if (!channel) return;
            if (vid._hls) { vid._hls.destroy(); vid._hls = null; }
            if (channel.url.endsWith('.m3u8') && window.Hls && Hls.isSupported()) {
                const hls = new Hls();
                hls.loadSource(channel.url);
                hls.attachMedia(vid);
                vid._hls = hls;
                vid.play().catch(() => {});
            } else {
                vid.src = channel.url;
                vid.play().catch(() => {});
            }
        });
    });
    if (window.feather) feather.replace();
}

function escMultiViewClose(e) {
    if (e.key === "Escape") closeMultiViewModal();
}

function closeMultiViewModal() {
    document.querySelectorAll('.multi-view-cell video').forEach(vid => {
        if (vid._hls) { vid._hls.destroy(); vid._hls = null; }
        vid.pause();
        vid.removeAttribute('src');
        vid.load();
    });
    const modal = document.getElementById('multiViewModal');
    if (modal) modal.remove();
    document.removeEventListener('keydown', escMultiViewClose, { once: true });
}

function setupMultiViewCloseBtn() {
    const closeBtn = document.querySelector('.multi-view-close-btn');
    closeBtn.innerHTML = '<span data-feather="x-circle" style="width:32px;height:32px;"></span>';
    Object.assign(closeBtn.style, {
        position: 'absolute',
        top: '24px',
        right: '32px',
        background: 'rgba(30,30,30,0.85)',
        color: '#fff',
        border: 'none',
        borderRadius: '50%',
        width: '48px',
        height: '48px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'pointer',
        zIndex: '10000',
        boxShadow: '0 2px 8px #0006'
    });
    closeBtn.addEventListener('click', closeMultiViewModal);
    if (window.feather) feather.replace();
    document.addEventListener('keydown', escMultiViewClose, { once: true });
}

function setupChromecast() {
    const castBtn = document.getElementById('castButton');
    if (!castBtn) return;

    castBtn.addEventListener('click', () => {
        if (!window.chrome || !window.chrome.cast || !window.cast) {
            showNotification("Chromecast is not available in this browser. Try using Google Chrome.");
            return;
        }
        const video = document.getElementById('player');
        if (!video || !video.src) {
            showNotification("Play a channel first before casting.");
            return;
        }
        const mediaInfo = new chrome.cast.media.MediaInfo(video.src, 'video/mp4');
        mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
        mediaInfo.metadata.title = document.title;
        const request = new chrome.cast.media.LoadRequest(mediaInfo);

        function onRequestSessionSuccess(session) {
            session.loadMedia(request,
                () => showNotification("Chromecast streaming started!"),
                () => showNotification("Failed to load media on Chromecast.")
            );
        }
        function onError() {
            showNotification("Failed to start Chromecast session.");
        }
        chrome.cast.requestSession(onRequestSessionSuccess, onError);
    });

    if (window.chrome && window.chrome.cast && window.cast) return;
    window['__onGCastApiAvailable'] = function(isAvailable) {
        if (isAvailable) {
            chrome.cast.initialize(
                new chrome.cast.ApiConfig(
                    new chrome.cast.SessionRequest(chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID),
                    () => {}, () => {}
                ),
                () => {}, () => {}
            );
        }
    };
}

function showEPGTab() {
    const playlistDiv = document.getElementById('playlist');
    playlistDiv.innerHTML = '<div class="epg-container" id="epgContainer"><strong>Loading EPG...</strong></div>';
    const EPG_XML_URL = "https://iptv-org.github.io/epg/guides/pk.xml";
    fetch(EPG_XML_URL)
        .then(resp => resp.text())
        .then(xmlText => {
            const parser = new DOMParser();
            const xml = parser.parseFromString(xmlText, "text/xml");
            const channels = Array.from(xml.querySelectorAll('channel')).slice(0, 10);
            let html = `
                <div class="epg-container">
                    <h3>Electronic Program Guide (EPG)</h3>
                    <table class="epg-table">
                        <thead>
                            <tr>
                                <th>Channel</th>
                                <th>Now</th>
                                <th>Next</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            channels.forEach(channel => {
                const id = channel.getAttribute('id');
                const displayName = channel.querySelector('display-name')?.textContent || id;
                const progs = Array.from(xml.querySelectorAll(`programme[channel="${id}"]`)).slice(0, 2);
                html += `
                    <tr>
                        <td>${displayName}</td>
                        <td class="epg-now">${progs[0] ? progs[0].getAttribute("start").slice(8, 12) + " - " + progs[0].getAttribute("stop").slice(8, 12) + "<br><b>" + progs[0].querySelector("title")?.textContent + "</b>" : "-"}</td>
                        <td class="epg-upcoming">${progs[1] ? progs[1].getAttribute("start").slice(8, 12) + " - " + progs[1].getAttribute("stop").slice(8, 12) + "<br><b>" + progs[1].querySelector("title")?.textContent + "</b>" : "-"}</td>
                    </tr>
                `;
            });
            html += `</tbody></table>
                <div style="margin-top:12px;font-size:0.95em;color:#cbd5e1;">Showing a preview of EPG. For complete EPG, see <a href="https://iptv-org.github.io/epg/" target="_blank" rel="noopener">IPTV-org EPG</a>.</div>
                </div>
            `;
            playlistDiv.innerHTML = html;
        })
        .catch(() => {
            playlistDiv.innerHTML = `<div class="epg-container"><strong style="color:#f87171;">Failed to load EPG data.</strong></div>`;
        });
}

function doBackup() {
    const backup = {
        favorites: JSON.parse(localStorage.getItem('favorites') || '[]'),
        recent: JSON.parse(localStorage.getItem('recent') || '[]'),
        history: JSON.parse(localStorage.getItem('history') || '[]'),
        lastPlaylist: JSON.parse(localStorage.getItem('lastPlaylist') || 'null'),
        theme: document.body.className || 'dark'
    };
    const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'proiptv-backup.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    showNotification("Backup downloaded!");
}

function doRestore() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = ".json,application/json";
    input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
            try {
                const data = JSON.parse(evt.target.result);
                if (data.favorites) localStorage.setItem('favorites', JSON.stringify(data.favorites));
                if (data.recent) localStorage.setItem('recent', JSON.stringify(data.recent));
                if (data.history) localStorage.setItem('history', JSON.stringify(data.history));
                if (data.lastPlaylist) localStorage.setItem('lastPlaylist', JSON.stringify(data.lastPlaylist));
                if (data.theme) document.body.className = data.theme;
                showNotification("Restore complete! Please refresh to apply all changes.");
            } catch (err) {
                showNotification("Restore failed: invalid backup file.");
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function showAnalyticsModal() {
    const fav = JSON.parse(localStorage.getItem('favorites') || '[]');
    const rec = JSON.parse(localStorage.getItem('recent') || '[]');
    const hist = JSON.parse(localStorage.getItem('history') || '[]');
    const modalRoot = document.getElementById('modalRoot');
    modalRoot.innerHTML = `
        <div class="multi-view-modal" id="analyticsModal" style="background:rgba(0,0,0,0.95);">
            <div style="min-width:320px;min-height:200px;background:#fff;color:#222;padding:28px 24px;border-radius:12px;box-shadow:0 2px 12px #0004;max-width:460px;">
                <h2 style="margin-top:0;margin-bottom:18px;">Analytics</h2>
                <ul style="list-style:none;padding:0;">
                    <li><b>Favorites count:</b> ${fav.length}</li>
                    <li><b>Recent watched:</b> ${rec.length}</li>
                    <li><b>History size:</b> ${hist.length}</li>
                </ul>
                <button onclick="document.getElementById('analyticsModal').remove()" style="margin-top:24px;padding:10px 20px;border-radius:6px;background:#111;color:#fff;"><span data-feather='x'></span> Close</button>
            </div>
        </div>
    `;
    if (window.feather) feather.replace();
}

function showCustomizationPanel() {
    const panel = document.getElementById('customizationPanel');
    panel.innerHTML = `
        <label>Theme:
            <select id="themeSelect">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
                <option value="cosmic">Cosmic</option>
            </select>
        </label>
        <button class="icon-btn" id="backupBtn" title="Backup">
            <span data-feather="save"></span>
        </button>
        <button class="icon-btn" id="restoreBtn" title="Restore">
            <span data-feather="rotate-ccw"></span>
        </button>
        <button class="icon-btn" id="analyticsBtn" title="Analytics">
            <span data-feather="bar-chart-2"></span>
        </button>
        <button class="icon-btn" id="multiViewGuideBtn" title="Multi-View Guide">
            <span data-feather="help-circle"></span>
        </button>
    `;
    document.getElementById('themeSelect').addEventListener('change', e => {
        document.body.className = e.target.value;
    });
    document.getElementById('backupBtn').addEventListener('click', doBackup);
    document.getElementById('restoreBtn').addEventListener('click', doRestore);
    document.getElementById('analyticsBtn').addEventListener('click', showAnalyticsModal);
    document.getElementById('multiViewGuideBtn').addEventListener('click', showMultiViewGuide);
    if (window.feather) feather.replace();
}

function setupAirPlay() {
    // Stub for AirPlay; real implementation requires Apple device support
}

function setupDLNA() {
    // Stub for DLNA; would use DIAL or SSDP/UPnP in real app
}

function showSubtitleControl(tracks) {
    const ctrl = document.getElementById('subtitleControl');
    ctrl.style.display = 'block';
    ctrl.innerHTML = `<strong>Subtitles:</strong> <select id="subtitleSelect">${tracks.map(t => `<option>${t.label}</option>`).join('')}</select>`;
}

function globalSearch(query) {
    showNotification(`Global search for "${query}"`);
}

function importPlaylistFromCloud() {
    showNotification('Cloud import feature coming soon!');
}

function showShortcutCustomization() {
    showNotification("Keyboard shortcut customization coming soon!");
}

async function initialize() {
    try {
        initializePlayer();

        const lastPlaylist = JSON.parse(localStorage.getItem('lastPlaylist'));
        if (lastPlaylist && lastPlaylist.content && lastPlaylist.type) {
            await processContent(lastPlaylist.content, lastPlaylist.type);
        }

        if (elements.fileUpload) elements.fileUpload.addEventListener('change', handleFileUpload);
        if (elements.toggleSidebar) elements.toggleSidebar.addEventListener('click', toggleSidebar);
        if (elements.toggleTheme) elements.toggleTheme.addEventListener('click', toggleTheme);
        if (elements.pipButton) elements.pipButton.addEventListener('click', togglePiP);
        if (elements.searchInput) elements.searchInput.addEventListener('input', debounce(handleSearch, 300));
        if (elements.groupFilter) elements.groupFilter.addEventListener('change', handleGroupFilter);
        elements.tabs.forEach(tab => tab.addEventListener('click', switchTab));
        document.addEventListener('keydown', handleShortcuts);
        document.addEventListener('click', handleFirstInteraction);
        if (elements.loadDefaultPlaylist) {
            elements.loadDefaultPlaylist.addEventListener('change', () => {
                if (elements.loadDefaultPlaylist.checked) {
                    loadFromURL();
                }
            });
        }
        if (elements.urlInput) elements.urlInput.value = '';
        if (elements.loadUrlBtn) {
            elements.loadUrlBtn.addEventListener('click', () => loadFromURL());
        }
        setInterval(backgroundStatusCheck, BACKGROUND_CHECK_INTERVAL);

        if (window.feather) feather.replace();
    } catch (e) {
        showError('Failed to initialize application: ' + e.message, 10000);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    initialize();
    showCustomizationPanel();

    const mvBtn = document.getElementById('multiViewButton');
    if (mvBtn) mvBtn.addEventListener('click', showMultiViewModal);

    const mvGuideBtn = document.getElementById('multiViewGuideIcon');
    if (mvGuideBtn) mvGuideBtn.addEventListener('click', showMultiViewGuide);

    setupChromecast();

    const epgTab = document.querySelector('.playlist-tab[data-tab="epg"]');
    if (epgTab) epgTab.addEventListener('click', showEPGTab);

    document.getElementById('player').addEventListener('click', () => {
        showChannelInfoOverlay({
            logo: '/assets/logo.png',
            name: 'Geo TV',
            group: 'Entertainment',
            program: 'Morning Show 08:00-10:00'
        });
    });

    document.getElementById('searchInput').addEventListener('keydown', e => {
        if (e.key === "Enter") globalSearch(e.target.value);
    });

    setTimeout(() => {
        scheduleReminder("Geo TV", "Morning Show", new Date(Date.now() + 15000).toISOString());
    }, 2000);

    setupAirPlay();
    setupDLNA();

    if (window.feather) feather.replace();
}); Here is css: /* General reset and body */
* {margin:0;padding:0;box-sizing:border-box;}
body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    height: 100vh;
    overflow: hidden;
    background: #0f1218;
    color: #e0e6ed;
    transition: background 0.3s ease, color 0.3s ease;
}
body.light {
    background: #f5f7fa;
    color: #1f2a44;
}

.container {
    display: flex;
    height: 100vh;
    width: 100vw;
    position: relative;
    transition: all 0.3s ease;
}

.sidebar {
    width: 320px;
    background: linear-gradient(180deg, #1a1f2b 0%, #141922 100%);
    padding: 24px;
    height: 100vh;
    transition: transform 0.3s ease;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    z-index: 10;
    position: absolute;
    left: 0;
    top: 0;
}
body.light .sidebar {
    background: linear-gradient(180deg, #ffffff 0%, #e5e7eb 100%);
    box-shadow: 2px 0 10px rgba(0,0,0,0.1);
}
.sidebar.collapsed { transform: translateX(-100%); }

.sidebar-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 24px;
}
.sidebar-header h1 {
    font-size: 1.5rem;
    font-weight: 600;
}
body.light .sidebar-header h1 {
    color: #1f2a44;
}

.input-group { margin-bottom: 5px; }
.input-group input[type="text"],
.input-group input[type="file"],
.input-group select {
    width: 100%;
    padding: 12px;
    background: #222834;
    border: 1px solid #333a4d;
    border-radius: 8px;
    color: #e0e6ed;
    font-size: 0.95rem;
    transition: border-color 0.2s;
}
body.light .input-group input[type="text"],
body.light .input-group input[type="file"],
body.light .input-group select {
    background: #fff;
    border: 1px solid #d1d5db;
    color: #1f2a44;
}
.input-group input:focus,
.input-group select:focus {
    outline: none;
    border-color: #3b82f6;
}
.input-group .url-input-container {
    display: flex;
    align-items: center;
    gap: 8px;
}
.input-group .load-url-btn {
    padding: 12px;
    background: #3b82f6;
    border: none;
    border-radius: 8px;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}
.input-group .load-url-btn:hover { background: #2563eb; }
.checkbox-group {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 10px;
    color: #e0e6ed;
}
body.light .checkbox-group { color: #1f2a44; }

.playlist-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 16px;
}
.playlist-tab {
    width: 40px;
    height: 40px;
    background: #222834;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}
body.light .playlist-tab {
    background: #e5e7eb;
    color: #1f2a44;
}
.playlist-tab.active {
    background: #3b82f6;
    color: white;
}

.playlist-container { flex: 1; overflow: hidden; position: relative; }
.playlist-scroll {
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    padding-right: 8px;
}
.playlist-scroll::-webkit-scrollbar { width: 6px; }
.playlist-scroll::-webkit-scrollbar-track { background: #222834; border-radius: 3px;}
.playlist-scroll::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 3px;}
body.light .playlist-scroll::-webkit-scrollbar-track { background: #e5e7eb; }
body.light .playlist-scroll::-webkit-scrollbar-thumb { background: #2563eb; }

.playlist-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px;
    background: #1c212e;
    border-radius: 8px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s;
    overflow-wrap: break-word;
}
body.light .playlist-item {
    background: #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.playlist-item:hover {
    background: #2a3142;
    transform: translateY(-1px);
}
body.light .playlist-item:hover { background: #f1f5f9; }
.playlist-item.active { background: #3b82f6; color: white; }
.playlist-item.active .now-playing { display: inline-block; }
.playlist-item img {
    width: 32px;
    height: 32px;
    border-radius: 6px;
    object-fit: cover;
}
.playlist-item .info {
    flex: 1;
    min-width: 0;
}
.playlist-item .channel-name {
    font-size: 0.95rem;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.playlist-item .favorite-btn {
    background: none;
    border: none;
    color: #94a3b8;
    cursor: pointer;
    transition: color 0.2s;
    display: flex;
    align-items: center;
}
body.light .playlist-item .favorite-btn { color: #6b7280; }
.playlist-item .favorite-btn.active { color: #f59e0b; }
.now-playing {
    display: none;
    font-size: 0.75rem;
    background: #22c55e;
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
}
.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-left: 8px;
}
.status-indicator.loading { background: #f59e0b; }
.status-indicator.playing { background: #22c55e; }
.status-indicator.error { background: #ef4444; }
.status-indicator.online { background: #22c55e; }
.status-indicator.offline { background: #ef4444; }
.status-indicator.unknown { background: #6b7280; }

.status-container {
    padding: 16px;
    background: #1c212e;
    border-radius: 8px;
    margin-bottom: 16px;
}
body.light .status-container {
    background: #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.status-container h3 { font-size: 1.1rem; margin-bottom: 12px; }
.status-container .stats {
    display: flex;
    gap: 16px;
    margin-bottom: 16px;
}
.status-container .stat { font-size: 0.9rem; }
.status-container .stat span { color: #3b82f6; font-weight: 600; }
body.light .status-container .stat span { color: #2563eb; }
.status-container canvas { max-width: 200px; margin: 0 auto; }
.status-container .resync-btn,
.status-container .view-playlist-btn {
    width: 100%;
    padding: 10px;
    background: #3b82f6;
    border: none;
    border-radius: 8px;
    color: white;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
    justify-content: center;
    margin-top: 8px;
}
.status-container .resync-btn:hover,
.status-container .view-playlist-btn:hover { background: #2563eb; }

.history-container {
    padding: 16px;
    background: #1c212e;
    border-radius: 8px;
    margin-bottom: 16px;
}
body.light .history-container {
    background: #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.history-container h3 { font-size: 1.1rem; margin-bottom: 12px; }
.history-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px;
    background: #222834;
    border-radius: 6px;
    margin-bottom: 8px;
}
body.light .history-item { background: #e5e7eb; }
.history-item .info { flex: 1; min-width: 0; }
.history-item .name {
    font-size: 0.9rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.history-item .type { font-size: 0.75rem; color: #94a3b8; }
body.light .history-item .type { color: #6b7280; }
.history-item button {
    background: none;
    border: none;
    color: #94a3b8;
    cursor: pointer;
    transition: color 0.2s;
    display: flex;
    align-items: center;
}
body.light .history-item button { color: #6b7280; }
.history-item button:hover { color: #3b82f6; }
body.light .history-item button:hover { color: #2563eb; }
.history-container .delete-all-btn {
    width: 100%;
    padding: 10px;
    background: #ef4444;
    border: none;
    border-radius: 8px;
    color: white;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.2s;
    margin-top: 12px;
}
.history-container .delete-all-btn:hover { background: #dc2626; }

.player-container {
    flex: 1;
    background: #000;
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}
.sidebar.collapsed ~ .player-container {
    position: absolute;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    flex: none;
}
#player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw !important;
    height: 100vh !important;
    min-width: 100vw !important;
    min-height: 100vh !important;
    object-fit: cover !important;
    background: #000;
    z-index: 1;
}
.plyr--video {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    min-width: 100vw !important;
    min-height: 100vh !important;
    object-fit: cover !important;
    background: #000 !important;
}
.plyr__poster {
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
}

.control-bar {
    position: absolute;
    top: 16px;
    right: 16px;
    display: flex;
    gap: 12px;
    z-index: 100;
}
.control-btn {
    width: 40px;
    height: 40px;
    background: rgba(31, 41, 55, 0.8);
    border: none;
    border-radius: 8px;
    color: #e0e6ed;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}
body.light .control-btn {
    background: rgba(255,255,255,0.8);
    color: #1f2a44;
}
.control-btn:hover { background: rgba(31,41,55,1);}
body.light .control-btn:hover { background: rgba(255,255,255,1); }

/* Place the Multi-View Guide icon below the Multi-View button in control bar */
.multiview-guide-icon {
    position: absolute;
    top: 68px;
    right: 100px;
    z-index: 101;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
}
.multiview-guide-icon .icon-btn {
    padding: 4px;
    border-radius: 50%;
    background: rgba(40,40,40,0.92);
    color: #fff;
}
.multiview-guide-icon .icon-btn:hover {
    background: #3b82f6;
    color: #fff;
}
@media (max-width:600px) {
    .multiview-guide-icon {
        right: 16px;
        top: 68px;
    }
}

.start-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    padding: 24px;
    border-radius: 12px;
    color: white;
    text-align: center;
    z-index: 200;
    animation: fadeIn 0.5s;
}
body.light .start-overlay {
    background: rgba(255,255,255,0.9);
    color: #1f2a44;
}

.error-toast {
    position: absolute;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(239,68,68,0.95);
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    z-index: 1000;
    display: none;
    animation: slideUp 0.3s;
}
.loading-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.9);
    padding: 24px;
    border-radius: 12px;
    color: white;
    text-align: center;
    z-index: 200;
    display: none;
}
body.light .loading-overlay {
    background: rgba(255,255,255,0.9);
    color: #1f2a44;
}
.loading-spinner {
    border: 3px solid rgba(255,255,255,0.3);
    border-top: 3px solid #3b82f6;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    animation: spin 1s linear infinite;
    display: inline-block;
    margin-right: 12px;
}
body.light .loading-spinner {
    border: 3px solid rgba(0,0,0,0.3);
    border-top: 3px solid #2563eb;
}
@keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideUp { from { transform: translate(-50%, 20px); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }

/* EPG styles */
.epg-container {
    padding: 10px;
    background: #181c25;
    color: #fff;
    border-radius: 8px;
    margin: 10px;
    max-height: 400px;
    overflow-y: auto;
}
.epg-table {
    width: 100%;
    border-collapse: collapse;
}
.epg-table th, .epg-table td {
    border: 1px solid #222;
    padding: 5px;
    font-size: 0.92rem;
}
.epg-now { background: #3b82f6; color: #fff; }
.epg-upcoming { background: #1f2a44; color: #facc15; }
body.light .epg-container { background: #f3f6fa; color: #222; }
body.light .epg-table th, body.light .epg-table td { border: 1px solid #ddd; }

/* Channel Info Overlay */
.channel-info-overlay {
    position: absolute;
    bottom: 96px;
    left: 32px;
    z-index: 50;
    background: rgba(22,23,30,0.92);
    color: #fff;
    border-radius: 8px;
    padding: 18px 24px;
    font-size: 1.08rem;
    min-width: 300px;
    box-shadow: 0 2px 10px #0005;
    display: flex;
    align-items: center;
    gap: 18px;
}
.channel-info-overlay img {
    width: 54px;
    height: 54px;
    object-fit: contain;
    border-radius: 8px;
    background: #fff;
}
body.light .channel-info-overlay {
    background: rgba(255,255,255,0.92);
    color: #222;
    box-shadow: 0 2px 10px #8884;
}

/* Subtitle Control */
.subtitle-control {
    position: absolute;
    bottom: 64px;
    right: 24px;
    background: rgba(0,0,0,0.92);
    color: #fff;
    border-radius: 6px;
    padding: 10px;
    z-index: 60;
}
body.light .subtitle-control { background: #f3f6fa; color: #222; }

/* Multi-View Modal improvements */
.multi-view-modal {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 100vw;
    min-height: 100vh;
}
.multi-view-grid {
    display: grid;
    gap: 12px;
    background: #111;
    border-radius: 14px;
    padding: 24px;
    box-shadow: 0 2px 32px #0008;
}
.multi-view-cell {
    background: #222;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    min-width: 200px;
    min-height: 120px;
}
.multi-view-cell select {
    background: rgba(30,30,30,0.92);
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 5px 8px;
    font-size: 0.98rem;
}
.multi-view-cell select:focus { outline: 2px solid #3b82f6; }
.multi-view-close-btn {
    background: rgba(30,30,30,0.85);
    border: none;
    border-radius: 50%;
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    position: absolute;
    top: 24px;
    right: 32px;
    z-index: 10000;
    cursor: pointer;
    box-shadow: 0 2px 8px #0006;
    transition: background 0.18s;
}
.multi-view-close-btn:hover { background: #222; }

/* Customization Panel - icons as buttons */
.customization-panel {
    margin-top: 18px;
    background: #111;
    color: #fff;
    border-radius: 10px;
    padding: 18px 14px;
    font-size: 1rem;
    min-height: 60px;
    display: flex;
    align-items: center;
    gap: 18px;
}
body.light .customization-panel { background: #f3f6fa; color: #222; }
.customization-panel label { margin-right: 20px; }
.customization-panel .icon-btn {
    background: none;
    border: none;
    padding: 8px;
    margin: 0 2px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.2s;
    color: inherit;
    display: inline-flex;
    align-items: center;
}
.customization-panel .icon-btn:hover {
    background: rgba(60,60,60,0.12);
}
.customization-panel .icon-btn.selected {
    background: #3b82f6;
    color: #fff;
}
.customization-panel .icon-label {
    margin-left: 5px;
    margin-right: 8px;
    font-size: 0.95em;
} Here is html: <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro IPTV Player</title>
    <link rel="icon" href="/assets/favicon.ico">
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/dashjs@latest/dist/dash.all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://unpkg.com/feather-icons"></script>
    <!-- Chromecast SDK -->
    <script type="text/javascript" src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
</head>
<body>
    <div id="notification-root"></div>
    <div class="container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span data-feather="tv"></span>
                <h1>Pro IPTV</h1>
            </div>
            <div class="input-group">
                <input type="file" id="fileUpload" accept=".m3u,.m3u8,.json,.txt">
                <div class="url-input-container">
                    <input type="text" id="urlInput" placeholder="Enter M3U/JSON/TXT URL">
                    <button class="load-url-btn" id="loadUrlBtn" title="Load URL">
                        <span data-feather="download"></span>
                    </button>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="loadDefaultPlaylist">
                    <label for="loadDefaultPlaylist">Load default playlist</label>
                </div>
            </div>
            <div class="input-group">
                <input type="text" id="searchInput" placeholder="Search channels...">
            </div>
            <div class="input-group">
                <select id="groupFilter">
                    <option value="all">All Groups</option>
                </select>
            </div>
            <div class="playlist-tabs">
                <div class="playlist-tab active" data-tab="all" title="All Channels"><span data-feather="list"></span></div>
                <div class="playlist-tab" data-tab="favorites" title="Favorites"><span data-feather="star"></span></div>
                <div class="playlist-tab" data-tab="recent" title="Recent"><span data-feather="clock"></span></div>
                <div class="playlist-tab" data-tab="status" title="Status"><span data-feather="info"></span></div>
                <div class="playlist-tab" data-tab="history" title="History"><span data-feather="book-open"></span></div>
                <div class="playlist-tab" data-tab="epg" title="EPG"><span data-feather="calendar"></span></div>
            </div>
            <div class="playlist-container">
                <div class="loading-overlay" id="loadingOverlay">
                    <span class="loading-spinner"></span>
                    <p>Validating channels...</p>
                </div>
                <div class="playlist-scroll" id="playlist"></div>
            </div>
            <div class="customization-panel" id="customizationPanel"></div>
        </div>
        <div class="player-container" id="playerContainer">
            <div class="control-bar">
                <button class="control-btn" id="toggleSidebar" title="Toggle Sidebar">
                    <span data-feather="menu"></span>
                </button>
                <button class="control-btn" id="toggleTheme" title="Toggle Theme">
                    <span data-feather="moon"></span>
                </button>
                <button class="control-btn" id="pipButton" title="Picture-in-Picture">
                    <span data-feather="maximize"></span>
                </button>
                <button class="control-btn" id="castButton" title="Chromecast">
                    <span data-feather="cast"></span>
                </button>
                <button class="control-btn" id="multiViewButton" title="Multi-View">
                    <span data-feather="grid"></span>
                </button>
            </div>
            <div class="channel-info-overlay" id="channelInfoOverlay" style="display:none"></div>
            <div class="start-overlay" id="startOverlay">
                <p><span data-feather="play-circle" style="width: 2em; height: 2em; vertical-align: middle;"></span><br>Select a channel to start streaming</p>
            </div>
            <video id="player" controls crossorigin playsinline poster="/assets/player-poster.webp"></video>
            <div class="error-toast" id="errorToast"></div>
            <div class="subtitle-control" id="subtitleControl" style="display:none"></div>
        </div>
        <div class="modal-root" id="modalRoot"></div>
    </div>
    <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>
    <script src="app.js"></script>
    <script>
      feather.replace();
    </script>
</body>
</html>
